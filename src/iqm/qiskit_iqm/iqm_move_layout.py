# Copyright 2024-2025 Qiskit on IQM developers
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Generate an initial layout for a quantum circuit that is
valid on the quantum architecture specification of the given backend."""
from typing import Optional, Union

from qiskit import QuantumCircuit
from qiskit.circuit import Qubit
from qiskit.dagcircuit import DAGCircuit
from qiskit.transpiler import PassManager, TranspilerError
from qiskit.transpiler.layout import Layout
from qiskit.transpiler.passes import TrivialLayout

from iqm.qiskit_iqm.iqm_backend import IQMBackendBase, IQMTarget


class IQMMoveLayoutOld(TrivialLayout):
    """Creates a qubit layout that is valid on the quantum architecture specification of the
    given IQM target with regard to the MOVE gate. In more detail, assumes that the MOVE
    operations in the quantum architecture define which physical qubit is the resonator and
    which is a MOVE qubit, and shuffles the logical indices of the circuit so that they match
    the requirements.

    This is required because Qiskit's basic layout algorithm assumes each connection between
    two qubits has the same gates defined.

    Note: This simple version of the mapper only works reliably with a single MOVE qubit
    and resonator, and only if the circuit contains at least one MOVE gate."""

    def run(self, dag: DAGCircuit):
        """Creates the qubit layout for the given quantum circuit.

        Args:
            dag (DAGCircuit): DAG to find layout for.

        Raises:
            TranspilerError: if dag wider than the target backend or if a valid mapping could not be found
        """
        # Run TrivialLayout to get the initial 1-to-1 mapping
        super().run(dag)
        changes = self._determine_required_changes(dag)
        if len(changes) < 1:
            # No need to shuffle any qubits
            return

        layout = self.get_initial_layout().get_physical_bits()
        new_dict = {}
        # Strict assignments
        # phys_idx to logical qubit (many logicals want the same physical, so just one of them appears in this map...)
        for src, dst in changes.items():
            new_dict[dst] = layout[src]

        for physical_qubit, logical_qubit in layout.items():
            if logical_qubit not in new_dict.values():
                # Non-clashing assignments
                if physical_qubit not in new_dict:
                    new_dict[physical_qubit] = logical_qubit
                else:
                    # Clashing assignment
                    alt_physical_qubit = [q for q in layout if q not in new_dict][0]
                    new_dict[alt_physical_qubit] = logical_qubit

        self.property_set['layout'] = Layout(new_dict)

    def get_initial_layout(self) -> Layout:
        """Returns the initial layout generated by the algorithm.

        Returns:
            The initial layout.
        """
        return self.property_set['layout']

    def _determine_required_changes(self, dag: DAGCircuit) -> dict[int, int]:
        """Scans the operations in the given circuit and determines what qubits
        need to be switched so that the operations are valid for the specified quantum architecture.

        Args:
            dag: circuit to check

        Returns:
            Required changes as a mapping of logical indices that should be switched.
        """
        reqs = self._calculate_requirements(dag)
        types = self._get_qubit_types()
        changes = {}
        for log_idx, required_type in reqs.items():
            if log_idx not in types or required_type != types[log_idx]:
                # direct phys_idx = log_idx mapping does not yield correct type
                # Need to change qubit at log_idx to required_type.
                # NOTE the in, "qubit" in "move_qubit" is True!
                # Find the first phys_idx that has compatible type
                matching_phys_idx = next((i for i, t in types.items() if required_type in t), None)
                # FIXME maps all qubits of that type in circuit to that same phys_idx,
                # unless they happen to map directly correctly?
                # FIXME since measure overwrites move_qubit with qubit in reqs, move qubits are not mapped correctly?!?
                # probably works because there is just one resonator, and it has the last physical index?
                if matching_phys_idx is None:
                    raise TranspilerError(f"Cannot find a '{required_type}' from the quantum architecture.")
                changes[log_idx] = matching_phys_idx
        return changes

    def _get_qubit_types(self) -> dict[int, str]:
        """Determine the type of the QPU component for each physical qubit index from the quantum architecture.

        We mark move_qubits and resonators using available MOVE gate loci.
        All other qubits become just "qubit".

        Returns:
            Mapping of physical qubit indices to qubit types for those
            qubits where the type is relevant.
        """
        target: IQMTarget = self.target
        qubit_types: dict[int, str] = {}
        for gate_name, gate_info in target.iqm_dqa.gates.items():
            if gate_name == 'move':
                for locus in gate_info.loci:
                    [qubit, resonator] = [target.iqm_component_to_idx[q] for q in locus]
                    if qubit is not None:
                        qubit_types[qubit] = 'move_qubit'
                    if resonator is not None:
                        qubit_types[resonator] = 'resonator'
        for i in range(target.num_qubits):
            if i not in qubit_types:
                qubit_types[i] = 'qubit'

        return qubit_types

    @staticmethod
    def _calculate_requirements(dag: DAGCircuit) -> dict[int, str]:
        """Determine the required type for each logical qubit in the circuit.

        Because MOVE gates have (qubit, resonator) loci, based on the MOVE gates in the circuit
        we can figure out which logical qubits must be mapped to computational resonators.
        FIXME also measured qubits are in the dict as "qubit"

        Args:
            dag: circuit to check

        Returns:
            Mapping of the logical qubit indices to the required type for that qubit.
        """
        required_types: dict[int, str] = {}

        def _require_type(qubit_index: int, required_type: str, instruction_name: str):
            if qubit_index in required_types and required_types[qubit_index] != required_type:
                # FIXME measure overwrites other required_types with 'qubit', why?
                # in proper use cases it overwrites move_qubits, never resonators, unless user made an error
                if instruction_name != 'measure':
                    raise TranspilerError(
                        f"""Invalid target '{qubit_index}' for the '{instruction_name}' operation,
                        qubit {qubit_index} would need to be {required_type} but it is already required to be
                        '{required_types[qubit_index]}'."""
                    )
            required_types[qubit_index] = required_type

        for node in dag.topological_op_nodes():
            if node.name == 'move':
                # The move operation requires that the first operand is the move qubit,
                # and the second must be the resonator
                (qubit, resonator) = node.qargs
                _require_type(dag.qubits.index(qubit), 'move_qubit', 'move')
                _require_type(dag.qubits.index(resonator), 'resonator', 'move')
        for node in dag.topological_op_nodes():
            if node.name == 'measure':
                for qubit in node.qargs:
                    _require_type(dag.qubits.index(qubit), 'qubit', 'measure')

        return required_types


class IQMMoveLayout(TrivialLayout):
    """Create a qubit layout that is valid on the dynamic quantum architecture of the
    given IQM target.

    The architecture defines which gate loci are available. This class
    tries to map the virtual/logical qubits of the circuit to the physical qubits
    of the architecture, such that the gates in the circuit can be applied on those qubits.

    This class required because Qiskit's basic layout algorithm assumes all connections between
    two qubits have the same two-qubit gates available.

    .. note::

       This version of the layout generator only works reliably with a single resonator,
       and can only handle pure Star architecture circuits.
    """

    def run(self, dag: DAGCircuit):
        """Creates the qubit layout for the given quantum circuit.

        Args:
            dag (DAGCircuit): DAG to find layout for.

        Raises:
            TranspilerError: if dag wider than the target backend or if a valid mapping could not be found
        """
        target = self.target

        # NOTE assumes we use the real Star architecture here
        reqs, resonators = self._calculate_requirements(dag)
        if len(resonators) > 1:
            raise TranspilerError(
                'Circuit requires more than one computational resonator, IQMMoveLayout cannot yet handle this.'
            )
        res_idx = target.iqm_component_to_idx[target.iqm_dqa.computational_resonators[0]]
        layout = {res_idx: dag.wires[next(iter(resonators))]}

        # map unused physical qubits to the gates they support
        free_qubits: dict[int, set[str]] = {}
        for op in ['move', 'cz', 'measure', 'r']:
            for locus in target.qargs_for_operation_name(op):
                free_qubits.setdefault(locus[0], set()).add(op)

        for log_idx, req_ops in reqs.items():
            # which physical qubits have the required ops available?
            mapping_options = [(phys_idx, len(av_ops)) for phys_idx, av_ops in free_qubits.items() if req_ops <= av_ops]
            # pick the one that has the fewest unneeded ops
            # TODO this heuristic does not always find a possible layout!
            if not mapping_options:
                raise TranspilerError(
                    f'Cannot find a physical qubit to map logical qubit {log_idx} to, '
                    f'requires {req_ops}, available: {free_qubits}.'
                )
            phys_idx, _ = min(mapping_options, key=lambda x: x[1])
            layout[phys_idx] = dag.wires[log_idx]
            del free_qubits[phys_idx]  # it's now taken

        self.property_set['layout'] = Layout(layout)

    def get_initial_layout(self) -> Layout:
        """Returns the initial layout generated by the algorithm.

        Returns:
            The initial layout.
        """
        return self.property_set['layout']

    @staticmethod
    def _calculate_requirements(dag: DAGCircuit) -> tuple[dict[int, set[str]], set[int]]:
        """Determine the requirements for each logical qubit in the circuit.

        Because in the Star architecture two-qubit gates have (qubit, resonator) loci, based on them
        we can figure out which logical qubits must be mapped to computational resonators.

        Args:
            dag: circuit to check

        Returns:
            Mapping of the logical qubit indices to the required gates for that qubit,
            logical qubit indices that must be resonators.
        """
        reqs: dict[int, set[str]] = {}
        resonators: set[int] = set()

        def _require_qubit_type(qubit: Qubit, required_type: str):
            """Add a requirement for the given qubit."""
            idx = dag.qubits.index(qubit)
            if idx in resonators:
                raise TranspilerError(
                    f"Virtual/logical qubit {qubit} for the '{node.name}' operation must be a qubit, "
                    f'but it is already required to be a resonator.'
                )
            reqs.setdefault(idx, set()).add(required_type)

        for node in dag.topological_op_nodes():
            if node.name in ('barrier',):
                continue
            if node.name in ('move', 'cz'):
                # In the real Star architecture, all arity-2 ops act on a (qubit, resonator) locus.
                qubit, resonator = node.qargs
                _require_qubit_type(qubit, node.name)
                # resonator
                idx = dag.qubits.index(resonator)
                if idx in reqs:
                    raise TranspilerError(
                        f"Virtual/logical qubit {resonator} for the '{node.name}' operation must be a resonator, "
                        f'but it is already required to be a qubit({reqs[idx]}).'
                    )
                resonators.add(idx)
            elif node.name == 'measure':
                _require_qubit_type(node.qargs[0], 'measure')
            else:
                # all single-qubit gates are mapped to r
                _require_qubit_type(node.qargs[0], 'r')

        return reqs, resonators


def generate_initial_layout(
    backend: IQMBackendBase,
    circuit: QuantumCircuit,
    restrict_to_qubits: Optional[Union[list[int], list[str]]] = None,
) -> Layout:
    """Generates an initial layout for the given circuit, when run against the given backend.

    Args:
        backend: IQM backend to run against.
        circuit: Star architecture circuit for which a layout is to be generated.

    Returns:
        Layout that maps the logical qubits of ``circuit`` to the physical qubits of ``backend`` so that
        all the gates in ``circuit`` are available on those loci.
    """
    target = backend.get_real_target()
    if restrict_to_qubits is not None:
        target = target.restrict_to_qubits(restrict_to_qubits)

    layout_gen = IQMMoveLayout(target)
    pm = PassManager(layout_gen)
    pm.run(circuit)
    return layout_gen.get_initial_layout()
